module Control.ConstraintKinds.Category
    where

import GHC.Prim
import GHC.TypeLits
import Data.Proxy
import qualified Data.Map as Map
import qualified Prelude as P

import qualified Data.Set as Set

-- -------------------------------------------------------------------------------
-- -- 
-- 
-- class Category cat where
-- 
--     type ValidCategory cat a b :: Constraint
--     type ValidCategory cat a b = ()
-- 
--     id :: ValidCategory cat a a => cat a a
-- 
--     infixr 9 .
--     (.) :: 
--         ( ValidCategory cat b c
--         , ValidCategory cat a b
--         , ValidCategory cat a c
--         ) => cat b c -> cat a b -> cat a c
-- 
-- -------------------
-- 
-- class SubCategory cat subcat where
--     embed :: ValidCategory subcat a b => subcat a b -> cat a b
-- 
-- instance SubCategory a a where
--     embed = id
-- 
-- -------------------
-- 
-- class Category cat => Groupoid cat where
--     inverse :: ValidCategory cat a b => cat a b -> cat b a
-- 
-- ---------------------------------------
-- 
-- data (><) cat1 cat2 a b = Product (cat1 a b, cat2 a b)
-- 
-- instance (Category cat1, Category cat2) => Category (cat1 >< cat2) where
--     type ValidCategory (cat1><cat2) a b = (ValidCategory cat1 a b, ValidCategory cat2 a b)
--     id = Product (id,id)
--     (Product (c1,d1)).(Product (c2,d2)) = Product (c1.c2,d1.d2)
-- 
-- ---------------------------------------
-- 
-- data (cat / (obj :: *)) a b = Slice (cat a b) 
-- 
-- instance Category cat => Category (cat/obj) where
--     type ValidCategory (cat/obj) a b = 
--         ( ValidCategory cat a obj
--         , ValidCategory cat b obj
--         , ValidCategory cat a b
--         , Category cat
--         )
-- 
--     id = Slice id
--     (Slice f).(Slice g) = Slice $ f.g
-- 
-- runSlice :: ValidCategory (cat/obj) a b => (cat/obj) a b -> (cat b obj) -> (cat a obj)
-- runSlice (Slice cat1) cat2 = cat2.cat1
-- 
-------------------------------------------------------------------------------

-- class Functor cat f where
--     fmap :: ValidCategory cat a b => cat a b -> f a -> f b
-- 
-- class Natural cat f1 f2 where
--     nmap :: cat a b -> f1 a -> f2 b
-- 
-- class Pointed f where
--     point :: a -> f a
-- 
-- pure :: Pointed f => a -> f a
-- pure = point
-- 
-- return :: Pointed f => a -> f a
-- return = point
-- 
-- class (Functor cat f, Pointed f) => Applicative cat f where
--     (<*>) :: ValidCategory cat a b => f (cat a b) -> f a -> f b 
-- 
-- class TypeMonoid m a where
--     join :: m (m a) -> m a
-- 
-- class Applicative cat m => Monad cat m where
-- 
--     (>>=) :: (TypeMonoid m b, ValidCategory cat a (m b)) => m a -> cat a (m b) -> m b
--     a >>= f = join $ fmap f a

-------------------------------------------------------------------------------

-- instance Category (->) where
--     id = P.id
--     (.) = (P..)
-- 
-- infixr 0 $
-- 
-- ($) :: (SubCategory (->) subcat, ValidCategory subcat a b) => subcat a b -> a -> b
-- ($) = embed

-------------------------------------------------------------------------------

-- newtype Constrained (xs :: [* -> Constraint]) a b = Constrained (a -> b)
-- 
-- type family AppConstraints (f :: [* -> Constraint]) (a :: *) :: Constraint
-- type instance AppConstraints '[] a = ()
-- type instance AppConstraints (x ': xs) a = (x a, AppConstraints xs a)
-- 
-- instance Category (Constrained xs) where
--     type ValidCategory (Constrained xs) a b = (AppConstraints xs a, AppConstraints xs b)
--     id = Constrained P.id
--     (Constrained f).(Constrained g) = Constrained (f.g)
-- 
-- instance SubCategory (->) (Constrained xs) where
--     embed (Constrained f) = f
-- 
-- embedOrd :: 
--     ( SubCategory (Constrained '[P.Ord]) subcat
--     , ValidCategory subcat a b
--     ) => subcat a b -> Constrained '[P.Ord] a b
-- embedOrd = embed

-------------------

-- instance Functor (Constrained '[P.Ord]) Set.Set where
--     fmap f set =  Set.map (embed f) set
-- 
-- instance Applicative (Constrained '[P.Ord]) Set.Set where
--     fs <*> xs = Set.unions [ fmap f xs | f <- Set.toList fs ]
-- 
-- instance Monad (Constrained '[P.Ord]) Set.Set where

-------------------------------------------------------------------------------

-- newtype Monotonic a b = Monotonic (a -> b)
-- 
-- instance Category Monotonic where
--     type ValidCategory Monotonic a b = (P.Ord a, P.Ord b)
--     id = Monotonic P.id
--     (Monotonic f) . (Monotonic g) = Monotonic (f.g)
-- 
-- instance SubCategory (->) Monotonic where
--     embed (Monotonic f) = f
-- 
-- instance SubCategory (Constrained '[P.Ord]) Monotonic where
--     embed (Monotonic f) = Constrained f
-- 
-- embedMonotonic :: 
--     ( SubCategory Monotonic subcat
--     , ValidCategory subcat a b
--     ) => subcat a b -> Monotonic a b
-- embedMonotonic = embed
-- 
-------------------

-- instance Functor Monotonic Set.Set where
--     fmap f set =  Set.mapMonotonic (embed f) set
-- 
-- instance Pointed Set.Set where
--     point = Set.singleton
-- 
-- instance Applicative Monotonic Set.Set where
--     fs <*> xs = Set.unions [ fmap f xs | f <- Set.toList fs ]
-- 
-- instance P.Ord a => TypeMonoid Set.Set a where
--     join set = Set.unions $ Set.toList set
-- 
-- instance Monad Monotonic Set.Set where
-- 
-------------------------------------------------------------------------------

-- class Monoid m where
--     zero :: m
--     add :: m -> m -> m
-- 
-- newtype Mon a b = Mon (a -> b)
-- 
-- instance Category Mon where
--     type ValidCategory Mon a b = (Monoid a, Monoid b)
--     id = Mon id
--     (Mon f).(Mon g) = Mon (f.g)
-- 
-- instance SubCategory (->) Mon where
--     embed (Mon f) = f
-- 
-- embedMon ::
--     ( SubCategory Mon subcat
--     , ValidCategory subcat a b
--     ) => subcat a b -> Mon a b
-- embedMon = embed
-- 
-- ---------------------------------------
-- 
-- class Monoid g => Group g where
--     negate :: g -> g
-- 
-- newtype Grp a b = Grp (a -> b)
-- 
-- instance Category Grp where
--     type ValidCategory Grp a b = (Group a, Group b)
--     id = Grp id
--     (Grp f).(Grp g) = Grp (f.g)
-- 
-- instance SubCategory (->) Grp where
--     embed (Grp f) = f
-- 
-- instance SubCategory Mon Grp where
--     embed (Grp f) = Mon f
-- 
-- embedGrp ::
--     ( SubCategory Grp subcat
--     , ValidCategory subcat a b
--     ) => subcat a b -> Grp a b
-- embedGrp = embed

-------------------------------------------------------------------------------

-- data BijectiveHask a b = BijectiveHask 
--     { forward :: (a -> b)
--     , backward :: (b -> a)
--     }
-- 
-- instance Category BijectiveHask where
--     id = BijectiveHask id id
--     (BijectiveHask f fi).(BijectiveHask g gi) = BijectiveHask (f.g) (gi.fi)
-- 
-- instance SubCategory (->) BijectiveHask where
--     embed = forward
-- 
-- instance Groupoid BijectiveHask where
--     inverse (BijectiveHask f fi) = BijectiveHask fi f
-- 
-- -------------------
-- 
-- newtype Index a = Index (Z (Order a))
--     deriving (P.Read,P.Show,P.Eq,P.Ord)
-- 
-- swapIndex :: Order a ~ Order b => Index a -> Index b
-- swapIndex (Index i) = Index i
-- 
-- class Finite a where
--     type Order a :: Nat
--     index :: a -> Index a
--     deIndex :: Index a -> a
--     enumerate :: [a]
--     
-- data SparseBijection a b = SparseBijection (Map.Map (Index a) (Index b)) (Map.Map (Index b) (Index a))
-- 
-- instance Category SparseBijection where
--     type ValidCategory SparseBijection a b = (Finite a, Finite b, Order a ~ Order b)
-- 
--     id :: forall a. ValidCategory SparseBijection a a => SparseBijection a a
--     id = SparseBijection idmap idmap
--         where
--             idmap = Map.fromList $ P.map (\a -> (index a,index a)) (enumerate :: [a])
-- 
--     (SparseBijection f1 fi1).(SparseBijection f2 fi2) = SparseBijection
--         (Map.map (\a -> find a f1) f2) 
--         (Map.map (\a -> find a fi2) fi1) 
--         where
--             find k map = case Map.lookup k map of
--                 P.Just v -> v
--                 P.Nothing -> swapIndex k
-- 
-- instance SubCategory BijectiveHask SparseBijection where
--     embed (SparseBijection f fi) = BijectiveHask (map2function f) (map2function fi)
--         where
--             map2function map k = case Map.lookup (index k) map of
--                 P.Just v -> deIndex v
--                 P.Nothing -> deIndex $ swapIndex $ index k
-- 
-- list2bijection :: (Finite a, Finite b, Order a ~ Order b) => [Z (Order a)] -> SparseBijection a b
-- list2bijection xs = SparseBijection (Map.fromList newlist) (Map.fromList $ P.map swap newlist)
--     where
--         newlist = go xs
--         swap (a,b) = (b,a)
-- 
--         go (y:[]) = [(Index y, Index $ P.head xs)]
--         go (y1:y2:ys) = (Index y1,Index y2):go (y2:ys)
-- 
-- type Sym (n::Nat) = SparseBijection (Z n) (Z n)
-- 
-- instance Finite a => Monoid (SparseBijection a a) where
--     zero = id
--     add = (.)
-- 
-- -------------------
-- 
-- newtype Z (n::Nat) = Z P.Integer
--     deriving (P.Read,P.Show,P.Eq,P.Ord)
-- 
-- instance KnownNat n => Finite (Z n) where
--     type Order (Z n) = n
--     index i = Index i
--     deIndex (Index i) = i
--     enumerate = [ Z i | i <- [0..n P.- 1] ]
--         where
--             n = natVal (Proxy :: Proxy n)
-- 
-- instance KnownNat n => Monoid (Z n) where
--     zero = Z 0
--     add (Z z1) (Z z2) = Z $ z1 P.+ z2 `P.mod` n
--         where
--             n = natVal (Proxy :: Proxy n)
-- 
-- instance KnownNat n => Group (Z n) where
--     negate (Z i) = Z $ P.negate i `P.mod` n
--         where
--             n = natVal (Proxy :: Proxy n)
-- 
-- -------------------

-- data SubType s a = SubType 
--     { generatingList :: [a]
--     , elem :: a
--     }
-- 
-- instance Monoid a => Monoid (SubType s a) where
--     zero = SubType [] zero
--     add (SubType a1) (SubType a2) = SubType $ add a1 a2
-- 
-- mkSubType :: Monoid a => [a] -> forall s. SubType s a
-- mkSubType xs = SubType xs zero

-------------------------------------------------------------------------------`
